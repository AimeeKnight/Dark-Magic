<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>It's Not Dark Magic - Pulling Back the Curtains From Your Stylesheets</title>

		<meta name="description" content="It's Not Dark Magic - Pulling Back the Curtains From Your Stylesheets">
		<meta name="author" content="Aimee Knight">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1>It's Not Dark Magic</h1>
          <h3>Pulling Back the Curtains From Your Stylesheets</h3>
					<p>
						<small>Created by
						  <a href="http://aimeemarieknight.com">Aimee Knight</a> /
						  <a href="http://twitter.com/Aimee_Knight">@Aimee_Knight</a>
						</small>
					</p>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/blinds.gif" >
					<aside class="notes">
						Trying to fix someone else's css
					</aside>
				</section>

				<section>
					<ul>
						<li>Software developers spend more time reading than writing source code</li>
						<li>Knowledge of internals can be useful for advanced debugging and performance tuning</li>
					</ul>
					<aside class="notes">
						why it’s important
					</aside>
				</section>

				<section>
					<h1>Vocabulary</h1>
					<ul>
						<li>Chromium (Open source browser)</li>
						<li>Chrome</li>
						<li>V8</li>
						<li>Chakra</li>
						<li>Webkit</li>
						<li>Blink</li>
						<li>Gecko</li>
						<li>Trident/EdgeHTML</li>
					</ul>
					<aside class="notes">
						Webkit (apple) forked into blink
						<br>
						2m loc
						<br>
						each tab has own rendering engine in chrome
					</aside>
				</section>

				<section>
					<h1>Parsing - High Level</h1>
					<ul>
						<li>Conversion</li>
						<li>Tokenization</li>
						<li>Nodes (block nodes & text nodes)</li>
					</ul>
					<aside class="notes">
						The HTML5 specification explains that these bytes undergo a process called 'tokenization', however before these bytes can be tokenized, they must first be converted into characters. 						
						<br>
						browser reads raw bytes of the HTML off the disk or network and translates them to individual based on specified encoding of the file
						<br>
						These tokens are then turned into nodes
					</aside>
				</section>

				<section>
					<h1>DOM (Elements)</h1>
					<ul>
						<li>Not context free</li>
						<li>Never get a syntax error</li>
					</ul>
					<aside class="notes">
						When constructing DOM tree, the browser first needs bytes from network
						<br>
						when parsing, you have to take into account surrounding chars
						<br>
						not defined - fudge factor
						<br>
						missing info, need more than the spec
						<br>
						edge cases
					</aside>
				</section>

				<section>
					<h1>Lexer</h1>
					<h4>(AKA tokenizer)</h4>
					<ul>
						<li>Breaks input into chunks (valid tokens)</li>
						<li>HTML tokens are start tags, end tags, attribute names and attribute values</li>
						<li>Knows how to strip irrelevant characters like white spaces and line breaks</li>
						<li>Outputs token stream</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Parser</h1>
					<ul>
						<li>Reads off lexer stream</li>
						<li>Responsible for analyzing the document structure according to the language syntax rules</li>
						<li>Constructs tree structure from stream</li>
						<li>The compiler first parses source code into a parse tree, and then translates the tree into a machine code document</li>
					</ul>
					<aside class="notes">
						tree structure similiar to AST = JS EX
					</aside>
				</section>

				<section>
					<h1>DOM</h1>
					<ul>
						<li>Source code &darr;</li>
						<li>Parsing &darr;</li>
						<li>Parse tree (think AST) &darr;</li>
						<li>Translation (compilation) &darr;</li>
						<li>Machine code</li>
					</ul>
					<aside class="notes">
						translation = turning AST into machine code
					</aside>
				</section>

				<section>
					<h1>Recap:</h1>
					<ul>
						<li>Browser sends HTTP request for page</li>
						<li>Web server sends response</li>
						<li>Browser converts response data (bytes) into tokens, via tokenization</li>
						<li>Browser turns tokens into nodes</li>
						<li>Browser turns nodes into the DOM tree</li>
						<li>DOM tree construction finished</li>
						<li>Awaits CSSOM tree construction</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/confused.gif" >
					<aside class="notes">
						Now for CSS
					</aside>
				</section>

				<section>
					<h1>CCSOM</h1>
					<ul>
						<li>By default CSS is treated as a render blocking resource</li>
						<li>Browser will hold rendering of any process until the CSSOM is constructed</li>
						<li>DOM can be built while loading scripts</li>
					</ul>
					<aside class="notes">
						Stylesheets are synchronous and block
					</aside>
				</section>

				<section>
					<h1>CCSOM</h1>
					<ul>
						<li>Not 1 to 1 with the DOM</li>
						<li>Display none, script tags, meta tags, head element, etc. are omitted since they're not reflected in the render output</li>
					</ul>
					<aside class="notes">
						Whereas elements with "hidden" visibility will appear in the tree
					</aside>
				</section>

				<section>
					<h1>CCSOM</h1>
					<ul>
						<li>CSS files are parsed into stylesheet objects</li>
						<li>Each object contains a CSS rules object</li>
						<li>Each rules objects contains selector and declaration objects and other objects corresponding to CSS grammar</li>
					</ul>
					<aside class="notes">
						Again, think AST/tree structure
					</aside>
				</section>

				<section>
					<h1>Render Tree</h1>
					<h4>DOM + CCSOM</h4>
					<ul>
						<li>Visual representation of the document</li>
						<li>Enable painting the contents in their correct order</li>
						<li>CSSOM Can have drastic effects on the render tree but none on the DOM tree</li>
					</ul>
					<aside class="notes">
						This tree is of visual elements in the order in which they will be displayed
					</aside>
				</section>

				<section>
					<h1>Purpose</h1>
					<ul>
						<li>Stores RenderObject's or "renderers" (AKA frames in Firefox)</li>
						<li>A renderer knows how to lay out and paint itself and its children</li>
						<li>Includes geometric information like width, height and position</li>
						<li>Each node in the DOM tree that produces visual output has a corresponding RenderObject</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Construction</h1>
					<ul>
						<li>Starting at the root of the DOM tree, traverse each visible node</li>
						<li>Omit non visible nodes</li>
						<li>For each visible node find the appropriate matching CSSOM rules and apply them</li>
						<li>Emit visible nodes with content and their computed styles</li>
						<li>Final output is a render tree that contains both the content and style information of all visible content on the screen</li>
					</ul>
					<aside class="notes">
						To construct a render tree, the browser does the following:
						<br>
						After proceeds to the layout stage
					</aside>
				</section>

				<section>
					<h1>Rendering Phases</h1>
					<ul>
						<li>Layout &darr;</li>
						<li>Paint &darr;</li>
						<li>Composite &darr;</li>						
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Layout</h1>
					<h4>(AKA Relow)</h4>
					<ul>
						<li>When the renderer is created and added to the tree, it does not have a position and size</li>
						<li>Calculating these values is called layout or reflow</li>
						<li>The output of the layout process is a "box-model" that contains the position and size of every element within the viewport</li>
					</ul>
					<aside class="notes">
						Up to this point we’ve calculated which nodes should be visible and their computed styles
						<br>
						but we haven't calculated their exact position & size within the viewport of the device
						<br>
						that’s the layout stage, also known as reflow
					</aside>
				</section>

				<section>
					<h1>Paint</h1>
					<h4>(AKA Rasterizing)</h4>
					<ul>
						<li>Once we have visible nodes (DOM), computed styles (CSSOM) and geometry (Layout), this information is passed to the second stage</li>
						<li>Converts each node in the render tree to actual pixels on the screen</li>
					</ul>
					<aside class="notes">
						Once the render tree is constructed, the browser can paint (draw) the render tree nodes on the screen
					</aside>
				</section>

				<section>
					<h1>Painting</h1>
					<ul>
						<li>Multiple rounds of painting can be caused by JS being loaded that changes the DOM</li>
						<li>Includes: text, colors, shadows, background images, etc.</li>
						<li>
							<a href="https://www.youtube.com/watch?v=ZTnIxIA5KGw">Gecko Reflow Visualization</a>
						</li>
					</ul>
					<aside class="notes">
						painting cont.
					</aside>
				</section>

				<section>
					<h1>Painting Time</h1>
					<ul>
						<li>Time varies based on render tree construction</li>
						<li>The bigger the width and height of the element, the longer the painting</li>
						<li>Adding different effects also increases painting time</li>
					</ul>
					<aside class="notes">
						The first thing to look for is the area of the element
					</aside>
				</section>
	
				<section>
					<h1>Painting Order</h1>
					<ul>
						<li>Painted from back to front</li>
						<li>Follows order that elements are stacked in their stacking contexts</li>
						<li>Example: background color &rarr; background image &rarr; border &rarr; children</li>
					</ul>
					<aside class="notes">
						Like layout, painting can also be global (entire tree is painted or incremental)
						<br>
						Incremental: some renderers change in way that doesn't affect entire tree
						<br>
						The changed renderer invalidates its rectangle on the screen causing the OS to see it as a "dirty region" and generate a "paint” event
					</aside>
				</section>
	
				<section>
					<h1>Composite</h1>
					<ul>
						<li>Render different elements of a web page in different layers (think photoshop layers)</li>
						<li>Action of flattening all layers into the final image that is visible on the screen</li>
					</ul>
					<aside class="notes">
						When people around the internet speak of hardware acceleration in web browsers, almost always refer to accelerated compositing
						<br>
						Composite where painted parts put together
					</aside>
				</section>

				<section>
					<h1>Summary</h1>
					<ul>
						<li>Browsers try to do the minimal possible actions in response to a change</li>
						<li>Changes to an element's color will only repaint that element</li>
						<li>Changes to the element's' position will cause layout and repaint of that element, its children and possibly siblings</li>
						<li>Adding a DOM node will cause layout and repaint of the node</li>
						<li>Major changes, like increasing font size of the html element will cause invalidation of caches, relayout and repaint of the entire tree</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/delete.gif" >
					<aside class="notes">
						Ever moved something around only to see another part of the page break?
					</aside>
				</section>

				<section>
					<h1>Cascade and Specificity</h1>
					<ul>
						<li>Applying rules in correct cascade order</li>
						<li>If multiple CSS selectors are targeting the same set of HTML elements, and if the CSS selectors are trying to assign the same property/properties to the HTML elements, the selector with the highest specificity value will “win”</li>
					</ul>
					<aside class="notes">
						TODO
					</aside>
				</section>

				<section>
					<h1>Specificity Cont.</h1>
					<ul>
						<li>There are many ways to target a specific tag using CSS selectors</li>
						<li>The browser needs a way to negotiate which color it should give to a specific tag</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Specificity Cont.</h1>
					<ul>
						<li>The way the browser makes the decision is by first calculating each selectors' specificity value</li>
						<li>Then it checks which selector has the highest value to determine the winner</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Positioning</h1>
					<img src="img/css_is_awesome">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Positioning</h1>
					<ul>
						<li>Before starting positioning layout, a tree of render objects is created</li>
						<li>When renderers are first created and added to the tree, they have no position or size yet</li>
					</ul>
					<aside class="notes">
						Can only happen once we have the render tree
						<br>
						All renderers have a layout method
						<br>
						The process by which all of the boxes have their positions and sizes determined is called layout
					</aside>
				</section>

				<section>
					<h1>Positioning Cont.</h1>
					<h3>Normal & Relative</h3>
					<ul>
						<li>Normal: The object is positioned according to its place in the document</li>
						<li>Relative: Positioned like usual and then moved by the required delta</li>
					</ul>
					<aside class="notes">
						Its place in the render tree is like its place in the DOM tree and laid out according to its box type and dimensions
					</aside>
				</section>

				<section>
					<h1>Positioning Cont.</h1>
					<h3>Float</h3>
					<ul>
						<li>The object is first laid out like normal flow, then moved as far left or right as possible</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<h1>Positioning Cont.</h1>
					<h3>Absolute</h3>
					<ul>
						<li>The object is put in the render tree in a different place than in the DOM tree</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>		

				<section>
					<h1>Positioning Phases</h1>
					<ul>
						<li>Layout is a recursive process</li>
						<li>The current renderer computes its width</li>
						<li>For each child, the current renderer: determines the position of the child, asks the child to compute its dimensions, finally, the current renderer computes its height</li>
					</ul>
					<aside class="notes">
						Parent tells child to fit into it’s width - also responsible for dimensions
						<br>
						This happens whenever a position changes - repaint and then composite back together still needs to happen
					</aside>
				</section>

				<section>
					<h1>Global and incremental layout</h1>
					<ul>
						<li>Layout can be triggered on the entire render tree as a result of a global style change that affects all renderers</li>
						<li>Global layout will usually be triggered synchronously</li>
						<li>Example: font size change, screen being resized</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Global and incremental layout</h1>
					<ul>
						<li>Layout can be incremental, where only the dirty renderers will be laid out</li>
						<li>Incremental layout is triggered asynchronously when renderers are dirty</li>
						<li>Example: when new renderers are appended to the render tree after extra content came from the network and was added to the DOM tree</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Z -Index</h1>
					<ul>
						<li>Every element in an HTML document can be either in front of or behind every other element in the document</li>
					</ul>
					<aside class="notes">
						So simple!
						<br>
						Elements with a higher z-index are stacked in front of elements with a lower z-index
					</aside>
				</section>

				<section>
					<img src="img/so_hard.gif" >
					<aside class="notes">
						It appears so simple, so most developers don’t take the time to read the rules.
					</aside>
				</section>

				<section>
					<h1>AKA Stacking Order</h1>
					<ul>
						<li>Groups of elements with a common parent that move forward or backward together in the stacking order make up what is known as a stacking context</li>
						<li>Every stacking context has a single HTML element as its root elemen</li>
						<li>When the z-index and position properties aren’t involved, the rules are simple: the stacking order is the same as the order of appearance in the HTML</li>
					</ul>
					<aside class="notes">
						Layered representation
						<br>
						When you introduce the position property into the mix, any positioned elements (and their children) are displayed in front of any non-positioned elements
						<br>
						To say an element is “positioned” means that it has a position value other than static, e.g., relative, absolute, etc
					</aside>
				</section>

				<section>
					<h1>What is a stacking context?</h1>
					<ul>
						<li>Stacking context is the three-dimensional conceptualization of HTML elements along an imaginary z-axis relative to the user who is assumed to be facing the viewport or the webpage</li>
						<li>A stacking context is an element that contains a set of layers</li>
						<li>This can be a root stacking context, as created by the html element</li>
						<li>Can be a local stacking context, as created by specific properties and values</li>
						<li>Within a local stacking context, the z-index values of its children are set relative to that element rather than to the document root</li>
						<li>Layers outside of that context — i.e. sibling elements of a local stacking context — can't sit between layers within it</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Stacking Order</h1>
					<ul>
						<li>z-index only works on positioned elements (if you try to set a z-index on an element with no position specified, it will do nothing)</li>
						<li>z-index values can create stacking contexts (this is where things get complicated)</li>
					</ul>
					<aside class="notes">
						At first it’s natural to assume elements with higher z-index values are in front of elements with lower z-index values, and any element with a z-index is in front of any element without a z-index, but it’s not that simple. 
					</aside>
				</section>

				<section>
					<h1>Stacking Context</h1>
					<ul>
						<li>When a new stacking context is formed on an element, that stacking context confines all of its child elements to a particular place in the stacking order</li>
						<li>If an element is contained in a stacking context at the bottom of the stacking order, there is no way to get it to appear in front of another element in a different stacking context that is higher in the stacking order</li>
					</ul>
					<aside class="notes">
						Can't even change if in diff contexts even with a z-index of a billion!
						A full understanding of stacking contexts is key to really grasping how z-index and the stacking order work.
					</aside>
				</section>

				<section>
					<h1>Stacking Context Rules</h1>
					<ul>
						<li>The stacking context’s root element</li>
						<li>Positioned elements (and their children) with negative z-index values higher values: stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML</li>
						<li>Non-positioned elements: ordered by appearance in the HTML</li>
						<li>Positioned elements (and their children) with a z-index value of auto: ordered by appearance in the HTML</li>
						<li>Positioned elements (and their children) with positive z-index values: higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML</li>
						<li>Positioned elements with negative z-indexes are ordered first within a stacking context, which means they appear behind all other elements</li>
					</ul>
					<aside class="notes">
						Here are the basic rules to determine stacking order within a single stacking context (from back to front)
						<br>
						Because of this, it becomes possible for an element to appear behind its own parent, which is normally not possible
						<br>
						This will only work if the element’s parent is in the same stacking context and is not the root element of that stacking context.
					</aside>
				</section>

				<section>
					<h1>Painting order</h1>
					<ul>
						<li>Elements with a negative stack level, typically elements with z-index: -1</li>
						<li>Elements with a position value of static</li>
						<li>Elements with a stack level of 0, typically positioned elements with a z-index value of auto</li>
						<li>Elements with positive stack levels, e.g. a positioned element with a z-index value of 1 or higher</li>
						<li>Two elements with the same stack level are layered based on their source order (successive elements stack on top of their predecessors)</li>
						<li>A handful of CSS properties and values trigger a new stacking context: opacity when its value is less than 1 (e.g.: .99), filter when its value is something other than none, and mix-blend-mode when its value is something other than normal</li>
						<li>The transform property can trigger a stacking context — but only when its value isn't none. This includes identity transforms1, such as scale(1) and translate3d(0,0,0)</li>
					</ul>
					<aside class="notes">
						Children of a stacking context are painted from bottom to top in the following order
					</aside>
				</section>

				<section>
					<h1>Debugging z-index</h1>
					<ul>
						<li>The key to avoid getting tripped up is being able to spot when new stacking contexts are formed</li>
						<li>If you’re setting a z-index of a billion on an element and it’s not moving forward in the stacking order, take a look up its ancestor tree and see if any of its parents form stacking contexts</li>
					</ul>
					<aside class="notes">
						If new stack context, your z-index of a billion isn’t going to do you any good.
					</aside>
				</section>

				<section>
					<h1>Conclusion</h1>
					<ul>
						<li>Begin constructing the DOM by parsing the HTML - DOM construction may be incremental, so response may not arrive all at once, so we may not finish constructing it all at once</li>
						<li>Request CSS and JavaScript resources - the browser send request for all CSS or JavaScript files. If the script is synchronous it will not be executed until the CSS is received (CSS is render-blocking)</li>
						<li>Execute JavaScript - completing the CSSOM will un-block the JavaScript engine and the scripts will be executed</li>
						<li>Merge the DOM and CSSOM into Render Tree - we have the DOM and CSSOM trees, so the browser will now build the Render Tree</li>
						<li>Run layout and paint - in this final step, the browser run the layout process and paint the page</li>
					</ul>
					<aside class="notes">
						So, here are the steps the browser goes through when loading a page:
					</aside>
				</section>

				<section>
					<img src="img/angry.gif" >
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/happy.gif" >
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Blank</h1>
					<ul>
						<li></li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section style="text-align: left;">
					<h1>Thank you!</h1>
					<ul>
						<li><a href="https://twitter.com/Aimee_Knight">@Aimee_Knight</a></li>
						<li><a href="https://github.com/AimeeKnight">GitHub: AimeeKnight</a></li>
					</ul>
				</section>

				<section>
					<ul>
						<li><cite></cite></li>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
