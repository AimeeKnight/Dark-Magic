<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>It's Not Dark Magic - Pulling Back the Curtains From Your Stylesheets</title>

		<meta name="description" content="It's Not Dark Magic - Pulling Back the Curtains From Your Stylesheets">
		<meta name="author" content="Aimee Knight">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1>It's Not Dark Magic</h1>
          <h3>Pulling Back the Curtains From Your Stylesheets</h3>
					<p>
						<small>Created by
						  <a href="http://aimeemarieknight.com">Aimee Knight</a> /
						  <a href="http://twitter.com/Aimee_Knight">@Aimee_Knight</a>
						</small>
					</p>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/amk_skate.gif" style="width: 370px;">
					<ul>
						<li>Work For: Warner Bros Digital Labs</li>
						<li>Hobbies: JavaScript Jabber, ‚õ∏, üèã, running</li>
						<li>Likes: üòªüòª, üçµ, kombucha</li>
					</ul>
					<aside class="notes">
						NSS
					</aside>
				</section>

				<section>
					<img src="img/blinds.gif" >
					<aside class="notes">
						Trying to fix someone else's CSS
					</aside>
				</section>

				<section>
					<blockquote>A language that doesn't affect the way you think about programming is not worth knowing. - Alan J. Perlis</blockquote>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h3>Can't I just use CSS in JS?</h3>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<ul>
						<li>No longer able to change one variable to update all colors</li>
						<li>Unable to affect children by parent classes</li>
					</ul>
					<aside class="notes">
						gain specificty, lose the cascade
					</aside>
				</section>

				<section>
					<ul>
						<li>Software developers spend more time reading than writing source code</li>
						<li>Knowledge of internals can be useful for advanced debugging and performance tuning</li>
						<li>In the future, we'll be able to modify the browsers rendering engine ourselves!</li>
					</ul>
					<aside class="notes">
						why it‚Äôs important
						<br>
						my story - front end
						<br>
						guessing vs systematic
					</aside>
				</section>

				<section>
					<h3>Houdini</h3>
					<ul>
						<li>Normalize cross-browser differences</li>
						<li>Invent or polyfill new features</li>
					</ul>
					<aside class="notes">
						jQuery for CSS
					</aside>
				</section>				
				
				<section>
					<blockquote>Low-level programming is good for the programmer‚Äôs soul. ‚Äì John Carmack</blockquote>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<ul>
						<li>Browser Internal</li>
						<li>Parsing Process</li>
						<li>Common Issues: specificity, positioning, z-index</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<h3>Vocabulary</h3>
					<table style="font-size: 80%">
					<tr>
						<td>Browsers</td>
						<td>
							<ul>
								<li>Chromium</li>
								<li>Chrome</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>Rendering Engines</td>
						<td>
							<ul>
								<li>Webkit <i>(Safari)</i></li>
								<li>Blink <i>(Chrome, Opera)</i></li>
								<li>Gecko <i>(Firefox)</i></li>
								<li>Trident <i>(IE)</i></li>
								<li>EdgeHTML <i>(Edge)</i></li>								
							</ul>
						</td>
					</tr>
					<tr>
						<td>JavaScript Engines</td>
						<td>
							<ul>
								<li>Nitro <i>(Safari)</i></li>									
								<li>V8 <i>(Chrome)</i></li>
								<li>SpiderMonkey <i>(Firefox)</i></li>		
								<li>Chakra <i>(IE)</i></li>								
								<li>Chakra <i>(Edge)</i></li>
							</ul>
						</td>
					</tr>											
					</table>
					<aside class="notes">
						Open source browser vs rendering/layout engine 
						<br>
						Webkit (apple) forked into blink, EdgeHTML = fork of trident
						<br>
						2m loc
						<br>
						each tab = own rendering engine
					</aside>
				</section>			

				<section>
					<h1>So, how do browsers actually work? ü§î</h1>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/browser_components.jpg" style="width: 800px;">
					<aside class="notes">
						UI: includes address bar, back/fwd btn, bookmarking menu, etc. Every part of browser display except window see requested page.
						BROWSER ENGINE: coordinates actions between UI - rendering engine.
						RENDERING ENGINE: displaying requested content. Parse HTML/CSS, displays parsed content on the screen.
						NETWORKING: HTTP requests.
						UI BACKEND: used for drawing basic boxes & windows. Underneath uses operating system.
						JS INTERPRETER. Parse & execute JS code.
						DATA STORAGE. Persistence layer. Saves data locally, such as cookies, localStorage.
					</aside>
				</section>	
				
				<section>
					<img src="img/main_flow.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/rendering_engine_dom.jpg" style="width: 80%">
					<aside class="notes">
					</aside>
				</section>

				<section>
						<pre><code><div class="container">
 <div id="main">
  <p>
   <a href="#">Link</a>
  </p>
 </div>
</div></code></pre>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/html_parser.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/how_browsers_work_breakdown.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/bytes.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Conversion</h1>
					<ul>
						<li>Reading raw bytes of HTML & CSS off of disk/network</li>
					</ul>
					<aside class="notes">
						browser reads raw bytes HTML/CSS off disk/network, translates to individual chars based on file encoding
					</aside>
				</section>				

				<section>
					<img src="img/characters.jpg">
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<img src="img/tokens.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Tokenizer</h1>
					<ul>
						<li>Breaks input valid tokens.</li>
						<li>HTML tokens: start tags, end tags, attribute names, attribute values</li>
						<li>Strips irrelevant characters: white space, line breaks.</li>
					</ul>
					<aside class="notes">
						often combined with lexing
					</aside>
				</section>

				<section>
					<h1>Tokenizer Output</h1>
						<pre><code>["<", "html", ">", 
     "<", "head", ">", 
         "<", "title", ">", "My HTML Page", "</", "title", ">",
     "</", "head", ">",
     "<", "body", ">",
         "<", "p", "style", "=", "\"", "special", "\"", ">",
            "This paragraph has special style",
        "</", "p", ">",
        "<", "p", ">",
            "This paragraph is not special",
        "</", "p", ">",
    "</", "body", ">",
"</", "html", ">"
]</code></pre>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Lexer</h1>
					<ul>
						<li>Like the tokenizer, but it also identifies the type of each token (this token is a number, that token is a string literal, this other token is an equality operator).</li>
						<li>Feeds token stream to the parser.</li>
					</ul>
					<aside class="notes">
						emitted tokens from tokenization are converted into 'objects' which define have their own properties & rules.
						<br>
						AKA does same as token plus attachs extra info to each token. If tokenize into words, lexer would attach tags like number, word, punctuation etc.
					</aside>
				</section>

				<section>
					<h1>Parser</h1>
					<ul>
						<li>Reads the stream of tokens from the lexer.</li>
						<li>Analyzes the document structure according to the language grammar (vocabulary + syntax rules.</li>
						<li>Compiler parses source code into a tree structure, and then translates that into machine code.</li>
					</ul>
					<aside class="notes">
						interprets tokens via grammar => tree (AST JS)
						<br>
						cares abt. sequence & combo of tokens detected fits expected grammar
						<br>
						other words: context in which token appears						
						<br>
						alpha order: lex then parse
					</aside>
				</section>

				<section>
					<img src="img/syntax_analysis.jpg">
					<aside class="notes">
					</aside>
				</section>				
	
				<section>
					<img src="img/dom.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>DOM</h1>
					<ul>
						<li>Not context free</li>
						<li>Never get a syntax error</li>
					</ul>
					<aside class="notes">
						when parsing, have to take into account surrounding chars, what came before or after
						<br>
						not defined - fudge factor
						<br>
						missing info, need more than the spec
						<br>
						edge cases
					</aside>
				</section>

				<section>
					<img src="img/fall_ice.gif">
					<aside class="notes">
						HTML = unconventional parser						
					</aside>
				</section>

				<section>
					<img src="img/jump.gif">
					<aside class="notes">
						CSS = conventional parser						
					</aside>
				</section>

				<section>
					<h1>Recap</h1>
					<ul>
						<li>Browser sends HTTP request for page</li>
						<li>Web server sends response</li>
						<li>Browser converts response data (bytes) into tokens, via tokenization</li>
						<li>Browser turns tokens into nodes</li>
						<li>Browser turns nodes into the DOM tree</li>
						<li>DOM tree construction finished</li>
						<li>Awaits CSSOM tree construction</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<img src="img/cssom_flow.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/confused.gif" >
					<aside class="notes">
						Now for CSS
						<br>
						DOM and CSSOM are independent data structures
						<br>
						As with HTML, need to convert received CSS rules into something browser can understand & work with. Hence, repeat HTML process, but for CSS instead
					</aside>
				</section>				
				
				<section>
						<pre><code>#main a {
  color: green;
}
p a {
  color: yellow;
}
.container #main a {
  color: pink;
}
div #main p a {
  color: orange;
}
a {
  color: red;
}</code></pre>
					<aside class="notes">
					</aside>
				</section>	
				
				<section>
					<h1>CSSOM</h1>
					<ul>
						<li>By default CSS is treated as a render blocking resource</li>
						<li>Browser will hold rendering of any process until the CSSOM is constructed</li>
					</ul>
					<aside class="notes">
						While browser constructs DOM, encounter link tag in head for sheet. Anticipation = needs for render, dispatches req
						<br>
						since sheets don't change DOM tree, no reason to stop parsing? Issue: scripts asking for style information during doc parsing. If style not loaded & parsed, script = wrong answers
					</aside>
				</section>			

				<section>
					<img src="img/css_parser.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>CSSOM</h1>
					<ul>
						<li>Not 1 to 1 with the DOM</li>
						<li>Display none, script tags, meta tags, head element, etc. are omitted since they're not reflected in the rendered output</li>
					</ul>
					<aside class="notes">
						DOM tree captures properties & relations of document markup, but doesn't tell how element will look when rendered. That‚Äôs responsibility of CSSOM
						<br>
						elements with 'hidden' visibility WILL appear in the tree
					</aside>
				</section>					

				<section>
					<img src="img/cssom.jpg">
					<aside class="notes">
					</aside>
				</section>
				
				<section>
					<h1>CSSOM</h1>
					<ul>
						<li>CSS files are parsed into <strong style="color: #42affa">stylesheet objects</strong></li>
						<li>Each stylesheet object contains a CSS <strong style="color: #42affa">rules object</strong></li>
						<li>Each rules object contains <strong style="color: #42affa">selector and declaration objects</strong> and <strong style="color: #42affa">other objects corresponding to CSS grammar</strong></li>
					</ul>
					<aside class="notes">
						AST/tree structure
						<br>
						When computing final set of styles for any obj on pg, browser starts with most general rule for a node (body element) then recursively refines computed styles by applying more specific rules (cascade down)
						<br>
						CSS loading has to be incremental because of cascade. Can‚Äôt paint something red and then paint blue later because that would be jarring						
					</aside>
				</section>				

				<section>
					<img src="img/render_tree.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/render_tree_construction.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Render Tree</h1>
					<h4>DOM + CSSOM</h4>
					<ul>
						<li>Visual representation of the document</li>
						<li>Enable painting the contents in their correct order</li>
						<li>CSSOM Can have drastic effects on the render tree but none on the DOM tree</li>
					</ul>
					<aside class="notes">
						tree is of visual elements in order in which displayed
						<br>
						since CSSOM can reorder nodes
					</aside>
				</section>

				<section>
					<h1>Purpose</h1>
					<ul>
						<li>Stores RenderObjects or "renderers" (AKA frames in Firefox)</li>
						<li>Knows how to lay out and paint itself and its children</li>
						<li>Includes geometric information like width, height and position</li>
						<li>Each node in the DOM tree that produces visual output has a corresponding RenderObject</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Construction</h1>
					<ul>
						<li>Starting at the root of the DOM tree, traverse each visible node</li>
						<li>Omit non visible nodes</li>
						<li>For each visible node find the matching CSSOM rules and apply it</li>
						<li>Emit visible nodes with content and computed styles</li>
						<li>Output a render tree that contains both the content and style information of all visible content on the screen</li>
					</ul>
					<aside class="notes">
						to construct render tree, browser does following:
						<br>
						after render tree - layout stage
					</aside>
				</section>

				<section>
					<img src="img/render_tree_construction_dom.jpg">
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<img src="img/render_tree_construction_cssom.jpg" style="width: 90%">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Rendering Phases</h1>
					<ul>
						<li>Layout &darr;</li>
						<li>Paint &darr;</li>
						<li>Composite &darr;</li>						
					</ul>
					<aside class="notes">
						Chrome DevTools perf tab capture & inspect construction/processing of DOM & CSSOM
					</aside>
				</section>				

				<section>
					<img src="img/layout_flow.jpg" style="width: 90%">
					<aside class="notes">
					</aside>
				</section>

				<!-- <section>
					<img src="img/flow.png" style="width: 1500px;">
					<aside class="notes">
					</aside>
				</section> -->

				<!-- <section>
					<ul>
						<li>Source code &darr;</li>
						<li>Parsing &darr;</li>
						<li>Parse tree (think AST) &darr;</li>
						<li>Translation (compilation) &darr;</li>
						<li>Machine code</li>
					</ul>
					<aside class="notes">
						created objs are linked in tree structure that captures parent-child relation from orig markup: HTML obj is parent of body obj, body parent of p obj, so on
						<br>
						translation: turns AST into machine code
					</aside>
				</section> -->

				<section>
					<h1>Layout</h1>
					<h4>(AKA Reflow)</h4>
					<ul>
						<li>When the renderer is created and added to the tree, it does not have a position and size</li>
						<li>Calculating these values is called layout or reflow</li>
						<li>The output of the layout process is a box model that contains the position and size of every element within the viewport</li>
					</ul>
					<aside class="notes">
						up to this we‚Äôve calculated which nodes should be visible and their computed styles
						<br>
						but haven't calculated their exact position & size within the viewport of the device
					</aside>
				</section>

				<section>
					<img src="img/paint_flow.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Paint</h1>
					<h4>(AKA Rasterizing)</h4>
					<ul>
						<li>Converts each node in the render tree to actual pixels on the screen</li>
					</ul>
					<aside class="notes">
						once you have visible nodes (DOM), computed styles (CSSOM) and geometry (Layout), the information is passed to the second stage and can draw the render tree
					</aside>
				</section>

				<section>
					<h1>Painting</h1>
					<ul>
						<li>Multiple rounds of painting can be caused by JS being loaded that changes the DOM</li>
						<li>Includes: text, colors, shadows, background images, etc.</li>
						<!-- <li>
							<a href="https://www.youtube.com/watch?v=ZTnIxIA5KGw" target="_blank">Gecko Reflow Visualization</a>
						</li> -->
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Painting Time</h1>
					<ul>
						<li>Time varies based on render tree construction</li>
						<li>The bigger the width and height of the element, the longer the painting time</li>
						<li>Adding different effects also increases painting time</li>
					</ul>
					<aside class="notes">
						first thing to look for is the area of the element
					</aside>
				</section>

				<section>
						<h1>Painting Time</h1>
						<ul>
							<li>Float: 14ms</li>
							<li>Flexbox: 3.5ms</li>							
						</ul>
						<aside class="notes">
							<br>
							flexbox is great from a usability standpoint
							<br>
							keep up with css skills
						</aside>
					</section>				
	
				<section>
					<h1>Painting Order</h1>
					<ul>
						<li>Follows order that elements are stacked in their stacking contexts</li>
						<li>Painted from back to front</li>
						<li>Example: background color &rarr; background image &rarr; border &rarr; children</li>
						<li>Can be global or incremental</li>
					</ul>
					<aside class="notes">
						Incremental: when styles change the renderer will become invalid causing OS to see it as a 'dirty region' & generates a 'paint' event
					</aside>
				</section>
	
				<section>
					<h1>Composite</h1>
					<ul>
						<li>Render different elements of a web page in different layers (think photoshop layers)</li>
						<li>Action of flattening all layers into the final image that is visible on the screen</li>
					</ul>
					<aside class="notes">
						hardware acceleration = compositing
						<br>
						GPU = speed up vs old CPU
						<br>
						cache & group chunks of render tree
						<br>
						painted parts put together
					</aside>
				</section>

				<section>
					<img src="img/reflow_repaint.jpg" style="width: 80%">
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<h1>Summary</h1>
					<ul>
						<li>Browsers try to do the minimal possible actions in response to a change</li>
						<li>Changes to the element's position will cause relayout and repaint of that element, its children and possibly siblings</li>						
						<li>Adding a DOM node will cause relayout and repaint of the parent node</li>						
						<li>Major changes, like increasing font size of the html element will cause relayout and repaint of the entire tree</li>
						<li>Changes to an element's color will only repaint that element</li>
					</ul>
					<aside class="notes">
						layout, will always trigger paint, since changing geometry of element means its pixels need to be fixed
					</aside>
				</section>

				<section>
					<img src="img/delete.gif" >
					<aside class="notes">
						ever moved something around only to see another part of page break?
					</aside>
				</section>

				<section>
					<blockquote>The amateur software engineer is always in search of magic. - Grady Booch</blockquote>
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<h1>Specificity</h1>
					<ul>
						<li>Applying rules in correct cascade order</li>
						<li>If multiple CSS selectors are targeting the same set of HTML elements, and if the CSS selectors are trying to assign the same property/properties to the HTML elements, the selector with the highest specificity value will win</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Specificity</h1>
					<ul>
						<li>Many ways to target a specific tag using CSS selectors</li>
						<li>Browser needs a way to negotiate which color it should give to a specific tag</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Specificity</h1>
					<ul>
						<li>Browser makes a decision by first calculating each selectors' specificity value</li>
						<li>Second, it checks which selector has the highest value to determine the winner</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h3>Selector Prerequisite Refresher</h3>						
					<table>
					<tr>
						<th>
							<h4>Type</h4>
						</th>
						<th>
							<h4>Examples</h4>								
						</th>
					</tr>
					<tr>
						<td>Attribute selectors</td>
						<td>
							<ul>
								<li>[type="text"]</li>
								<li>[rel="nofollow"]</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>Pseudo-classes</td>
						<td>
							<ul>
								<li>:hover</li>
								<li>:visited</li>
							</ul>
						</td>
					</tr>	
					<tr>
						<td>Pseudo-elements</td>
						<td>
							<ul>
								<li>::before</li>
								<li>::after</li>
							</ul>
						</td>
					</tr>								
					</table>
					<aside class="notes">
						all know type (div) selectors, class and id...
					</aside>
				</section>

				<section>
						<pre><code><div class="container">
 <div id="main">
  <p>
   <a href="#">Link</a>
  </p>
 </div>
</div></code></pre>

						<pre><code>#main a {
  color: green;
}
p a {
  color: yellow;
}
.container #main a {
  color: pink;
}
div #main p a {
  color: orange;
}
a {
  color: red;
}</code></pre>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/sponge_bob.gif">
					<h1 class="fragment fade-in">Answer: <span style="color:#FF69B4;">Pink!</span></h1>
				</section>	

				<section>
					<table style="font-size: 70%">
					<tr>
						<th>
							<h5>Selector</h5>
						</th>
						<th>
							<h5>Specificity Value (<span style="color: #9932CC">A</span>,<span style="color: #00BFFF">B</span>,<span style="color: #7CFC00">C</span>,<span style="color: #EE82EE">D</span>)</h5>						
						</th>
					</tr>
					<tr>
						<td>.container #main a</td>
						<td><span style="color: #EE82EE">0</span>,<span style="color: #9932CC">1</span>,<span style="color: #00BFFF">1</span>,<span style="color: #7CFC00">1</span></td>
					</tr>
					<tr>
						<td>div #main p a</td>
						<td><span style="color: #EE82EE">0</span>,<span style="color: #9932CC">1</span>,<span style="color: #00BFFF">0</span>,<span style="color: #7CFC00">3</span></td>						
					</tr>	
					<tr>
						<td>#main a</td>
						<td><span style="color: #EE82EE">0</span>,<span style="color: #9932CC">1</span>,<span style="color: #00BFFF">0</span>,<span style="color: #7CFC00">1</span></td>												
					</tr>				
					<tr>
						<td>p a</td>
						<td><span style="color: #EE82EE">0</span>,<span style="color: #9932CC">0</span>,<span style="color: #00BFFF">0</span>,<span style="color: #7CFC00">2</span></td>																		
					</tr>	
					<tr>
						<td>a</td>
						<td><span style="color: #EE82EE">0</span>,<span style="color: #9932CC">0</span>,<span style="color: #00BFFF">0</span>,<span style="color: #7CFC00">1</span></td>																		
					</tr>							
					</table>
					<p class="fragment fade-in" style="color: #EE82EE; font-size: 40px !important">A: Styles attribute (1,0,0,0 points)</p>					
					<p class="fragment fade-in" style="color: #9932CC; font-size: 40px !important">B: Number of ID selectors (0,1,0,0 points)</p>					
					<p class="fragment fade-in" style="color: #00BFFF; font-size: 40px !important">C: Number of class selectors, attribute selectors, pseudo-classes (0,0,1,0 points)</p>					
					<p class="fragment fade-in" style="color: #7CFC00; font-size: 40px !important">D: Number of type selectors, pseudo-elements (0,0,0,1 points)</p>					
					<aside class="notes">
						had to write down my calculations on a piece of paper
					</aside>
				</section>

				<section>
					<h4>Specificity value: 0,1,2,2</h4>		
					<pre><code>#header .navbar li a:visited</code></pre>
					<table>
						<tr>
							<th>A</th>								
							<th>B</th>
							<th>C</th>
							<th>D</th>							
						</tr>
						<tr>
							<td>0</td>								
							<td>1</td>
							<td>2</td>
							<td>2</td>
						</tr>
					</table>
					<aside class="notes">
						0 style attrs, 1 id, 1 class + 1 pseudo-class, 2 type selectors (li, a)
					</aside>
				</section>

				<section>
					<h1>Specificity</h1>
					<ul>
						<li>You can read values as if they were a number. 1,2,2 = 122.</li>
						<li>Commas are there to remind us that it's not a base 10 system.</li>
						<li>Can have a specificity value of 0,1,13,4 and 13 won't spill over like a base 10 system.</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Positioning</h1>
					<img src="img/css_is_awesome.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Positioning</h1>
					<ul>
						<li>Before starting layout (positioning), a tree of render objects is always required</li>
						<li>When renderers are first created and added to the render tree, they have no position or size yet</li>
						<li>All renderers have own layout method</li>
					</ul>
					<aside class="notes">
						process of determining the position and size of all boxes = going back to layout
					</aside>
				</section>

				<section>
					<h1>Positioning</h1>
					<h4>Normal & Relative</h4>
					<ul>
						<li>Normal: The object is positioned according to its place in the document, box type, and dimensions</li>
						<li>Relative: Positioned like usual and then moved by the required delta</li>
					</ul>
					<aside class="notes">
						block: has own rectangle on the browser window
						<br>
						inline: does not have its own block, is inside containing block
					</aside>
				</section>

				<section>
					<h1>Positioning</h1>
					<h4>Float</h4>
					<ul>
						<li>The object is first laid out in normal flow, then moved as far left/rt as possible</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<h1>Positioning</h1>
					<h4>Absolute</h4>
					<ul>
						<li>The object is put in the render tree in a different place than in the DOM tree</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>		

				<section>
					<h1>Positioning Phases</h1>
					<ul>
						<li>Layout is a recursive process</li>
						<li>The current renderer computes its width</li>
						<li>For each child, the current renderer: determines the position of the child, asks the child to compute its dimensions, then the current renderer can compute its height</li>
					</ul>
					<aside class="notes">
						parent tells child to fit into it‚Äôs width
						<br>
						happens whenever position changes
						<br>
						repaint and then composite back together still needs to happen
					</aside>
				</section>

				<section>
					<img src="img/layout.jpg" style="width: 80%">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Global Layout</h1>
					<ul>
						<li>Layout can be triggered on the entire render tree as a result of a global style change that affects all renderers</li>
						<li>Global layout will usually be triggered synchronously</li>
						<li>Example: font size change, screen being resized</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Incremental layout</h1>
					<ul>
						<li>Layout can be incremental, where only the dirty renderers will be laid out</li>
						<li>Incremental layout is triggered asynchronously when renderers are dirty</li>
						<li>Example: new renderers are appended to the render tree after extra content came from the network and was added to the DOM tree</li>
					</ul>
					<aside class="notes">
						remember renderer object in render tree, knows how to layout & paint itself & children
					</aside>
				</section>

				<section>
					<h1>Z -Index</h1>
					<ul>
						<li>Every element in an HTML document can be either in front of or behind every other element in the document</li>
					</ul>
					<aside class="notes">
						elements with higher z-index are stacked in front of elements with lower z-index
					</aside>
				</section>

				<section>
					<img src="img/so_hard.gif" >
					<aside class="notes">
						appears so simple, so most devs don‚Äôt take time to read rules
					</aside>
				</section>

				<section>
					<h1>What is a stacking context?</h1>
					<ul>
						<li>A three-dimensional representation of HTML elements along an imaginary z-axis relative to the user facing the viewport</li>
						<li>An element that contains a set of layers</li>
						<li>Groups of elements with a common parent that move forward or backward together</li>
					</ul>
					<aside class="notes">
						full understanding of stacking contexts is key to grasping how z-index & stacking order work
						<br>
						layered representation
					</aside>
				</section>

				<section>
					<h1>Stacking Order</h1>
					<ul>
						<li>Every stacking context has a single HTML element as its root element</li>
						<li>When z-index and position properties aren‚Äôt involved, the rules are simple: the stacking order is the same as the order of appearance in the HTML</li>
					</ul>
					<aside class="notes">
						when you introduce position property, positioned elements (& children) can be displayed in front of non-positioned elements
						<br>
						'positioned' means relative, absolute, etc. (value other than static)
					</aside>
				</section>

				<section>
					<h1>Stacking Context</h1>
					<h4>Types</h4>
					<ul>
						<li>Root Stacking Context: created by an html element</li>
						<li>Local Stacking Context: created by specific properties and values</li>
						<li>Within a local stacking context, the z-index values of children are relative to the root element rather than to the document root</li>
						<li>Layers outside of a context (sibling elements of a local stacking context) can't sit between layers within that context</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Stacking Context</h1>
					<ul>
						<li>When a new stacking context is formed on an element, that stacking context confines all of its child elements to a particular place in the stacking order</li>
						<li>If an element is contained in a stacking context at the bottom of the stacking order, there is no way to get it to appear in front of another element in a different stacking context that is higher in the stacking order</li>
					</ul>
					<aside class="notes">
						<br>
						diff contexts ? can't even change even with a z-index of billion!
					</aside>
				</section>

				<section>
					<h1>Stacking Context Rules</h1>
					<h4>Non-positioned elements</h4>
					<ul>
						<li>Check the stacking context‚Äôs root element</li>
						<li>Check order of appearance in the HTML</li>
					</ul>
					<aside class="notes">
						here are basic rules to determine stacking order w/in simple single stacking context (from back to front)
					</aside>
				</section>

				<section>
					<h1>Stacking Context Rules</h1>
					<h4>Positioned elements (and their children)</h4>
					<ul>
						<li>Negative z-index values: higher values are stacked in front of lower values and elements with the same value are stacked according to appearance in the HTML</li>
						<li>Negative z-indexes are ordered first within a stacking context, which means they appear behind all other elements</li>
					</ul>
					<aside class="notes">
						-1 higher than -5
						<br>
						(2)...because of this, possible for an element to appear behind own parent - normally not possible. Only works if element‚Äôs parent is in same stacking context & not root element of that context
					</aside>
				</section>

				<section>
					<h1>Stacking Context Rules</h1>
					<h4>Positioned elements (and their children)</h4>
					<ul>
						<li>Auto z-index values: ordered by appearance in the HTML</li>
						<li>Positive z-index values: higher values are stacked in front of lower values and elements with the same value are stacked according to appearance in the HTML</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<h1>Painting order</h1>
					<ul>
						<li>Negative stack level, typically elements with z-index: -1</li>
						<li>Position value of static</li>
						<li>Stack level 0, typically positioned elements with a z-index value of auto</li>
						<li>Positive stack levels, e.g. a positioned element with a z-index value of 1 or higher</li>
						<li>Elements with the same stack level are layered based on their source order (successive elements stack on top of their predecessors)</li>
					</ul>
					<aside class="notes">
						children of a stacking context are painted from bottom to top in following order
					</aside>
				</section>

				<section>
					<h1>New Stacking Contexts</h1>
					<ul>
						<li>Some additional properties can create new stacking contexts (this is where things get complicated)!</li>
						<li>Only works on positioned elements (if you try to set a z-index on an element with no position specified, it won't do anything)</li>
					</ul>
					<aside class="notes">
						At first it‚Äôs natural to assume elements with higher z-index values are in front of elements with lower values
						<br>
						& any element with z-index is in front of any element without a z-index
						<br>
						but it‚Äôs not that simple
					</aside>
				</section>

				<section>
					<h1>New Stacking Contexts</h1>
					<ul>
						<li>Opacity less than 1, filter when its value is something other than none, and mix-blend-mode when its value is something other than normal</li>
						<li>Transform property also triggers a stacking context when its value isn't none. Examples: scale(1), translate3d(0,0,0)</li>
					</ul>
					<aside class="notes">
						blend mode determines how the pixels on that layer interact with the visible pixels on the layers below it
						<br>
						scale: size, translate3d: GPU into action for CSS transitions, making them smoother
					</aside>
				</section>

				<section>
					<h1>Debugging z-index</h1>
					<ul>
						<li>Be able to spot when new stacking contexts are formed</li>
						<li>Look up the ancestor tree and see if any parents form stacking contexts</li>
					</ul>
					<aside class="notes">
						if setting z-index of billion on element & not moving forward in stacking order...
					</aside>
				</section>

				<section>
					<h1>Debugging z-index</h1>
					<img src="img/stacking_context.png" >					
					<aside class="notes">
					</aside>
				</section>		

				<section>
					<h1>Conclusion</h1>
					<ul>
						<li>Construct the DOM by parsing the HTML</li>
						<li>May be incremental and a response may not arrive all at once, so may not finish construction all at once</li>
						<li>Request CSS and JavaScript resources</li>
						<li>If scripts are synchronous it will not be executed until the CSS is received since CSS is render-blocking</li>
					</ul>
					<aside class="notes">
						here are steps the browser goes through when loading page
					</aside>
				</section>

				<section>
					<h1>Conclusion</h1>
					<ul>
						<li>Complete CSSOM construction to un-block the JavaScript engine</li>
						<li>Execute JavaScript</li>
						<li>Merge the DOM and CSSOM into the Render Tree</li>
						<li>Run layout, paint, and composite</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/angry.gif" >
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/happy.gif" >
					<aside class="notes">
					</aside>
				</section>

				<section>
					<blockquote>Computers are good at following instructions, but not at reading your mind. - Donald Knuth</blockquote>
					<aside class="notes">
					</aside>
				</section>				

				<section style="text-align: left;">
					<h1>Thank you!</h1>
					<ul>
						<li><a href="https://twitter.com/Aimee_Knight">@Aimee_Knight</a></li>
						<li><a href="https://github.com/AimeeKnight">GitHub: AimeeKnight</a></li>
					</ul>
				</section>

				<section>
					<ul>
						<li>
							<a href="https://gist.github.com/AimeeKnight/77b36738ec876965c6db5c6d39f4ef4f">References</a>
						</li>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
