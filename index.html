<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>It's Not Dark Magic - Pulling Back the Curtains From Your Stylesheets</title>

		<meta name="description" content="It's Not Dark Magic - Pulling Back the Curtains From Your Stylesheets">
		<meta name="author" content="Aimee Knight">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1>It's Not Dark Magic</h1>
          <h3>Pulling Back the Curtains From Your Stylesheets</h3>
					<p>
						<small>Created by
						  <a href="http://aimeemarieknight.com">Aimee Knight</a> /
						  <a href="http://twitter.com/Aimee_Knight">@Aimee_Knight</a>
						</small>
					</p>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/blinds.gif" >
					<aside class="notes">
						Trying to fix someone else's css
					</aside>
				</section>

				<section>
					<ul>
						<li>Software developers spend more time reading than writing source code</li>
						<li>Knowledge of internals can be useful for advanced debugging and performance tuning</li>
					</ul>
					<aside class="notes">
						why it’s important
						<br>
						my story - front end
						<br>
						guessing vs systematic
					</aside>
				</section>

				<section>
					<h1>Vocabulary</h1>
					<table>
					<tr>
						<td>Browsers</td>
						<td>
							<ul>
								<li>Chromium</li>
								<li>Chrome</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>Rendering Engines</td>
						<td>
							<ul>
								<li>Webkit</li>
								<li>Blink</li>
							<li>Gecko</li>
							<li>Trident/EdgeHTML</li>								
							</ul>
						</td>
					</tr>
					<tr>
						<td>JavaScript Engines</td>
						<td>
							<ul>
								<li>V8</li>
								<li>Chakra</li>
							</ul>
						</td>
					</tr>													
					</table>
					<aside class="notes">
						Open source browser vs rendering/layout engine 
						<br>
						Webkit (apple) forked into blink - Gecko = Firefox, EdgeHTML = fork of trident for IE11
						<br>
						2m loc
						<br>
						each tab has own rendering engine
					</aside>
				</section>

				<section>
					<img src="img/layers.png" style="width: 800px;">
					<aside class="notes">
						UI: includes address bar, back/forward button, bookmarking menu, etc. Every part of browser display except the window where you see the requested page.
						BROWSER ENGINE: coordinates actions between UI and rendering engine.
						RENDERING ENGINE: responsible for displaying requested content. Parses HTML and CSS, and displays the parsed content on the screen.
						NETWORKING: Network calls such as HTTP requests.
						UI BACKEND: used for drawing basic boxes & windows. Underneath it uses operating system user interface methods.
						JS INTERPRETER. Parse & execute JS code.
						DATA STORAGE. Persistence layer. Saves data locally, such as cookies, localStorage.
					</aside>
				</section>				

				<section>
					<h1>Parsing - High Level</h1>
					<ul>
						<li>Conversion</li>
						<li>Tokenization</li>
						<li>Lexing</li>
						<li>Parsing</li>						
					</ul>
					<aside class="notes">
						HTML5 spec > bytes converted to chars then undergo 'tokenization' process
						<br>
						chars > tokens > obj. are turned into text & block nodes for DOM construction
					</aside>
				</section>

				<section>
					<img src="img/flow.png" style="width: 1500px;">
					<aside class="notes">
					</aside>
				</section>					

				<section>
					<h1>Conversion</h1>
					<ul>
						<li>Reading raw bytes of HTML & CSS off of disk/network</li>
					</ul>
					<aside class="notes">
						!!browser reads raw bytes HTML/CSS off disk/network, translates to individual chars based on file encoding!!
					</aside>
				</section>

				<section>
					<h1>Tokenizer</h1>
					<ul>
						<li>Breaks input into chunks</li>
						<li>HTML tokens: start tags, end tags, attribute names, attribute values</li>
						<li>Strips irrelevant characters: white space, line breaks</li>
					</ul>
					<aside class="notes">
						!!breaks into chunks (valid tokens)!!
						often combined with lexing
					</aside>
				</section>

				<section>
					<h1>Tokenizer</h1>
						<pre><code>["<", "html", ">", 
     "<", "head", ">", 
         "<", "title", ">", "My HTML Page", "</", "title", ">",
     "</", "head", ">",
     "<", "body", ">",
         "<", "p", "style", "=", "\"", "special", "\"", ">",
            "This paragraph has special style",
        "</", "p", ">",
        "<", "p", ">",
            "This paragraph is not special",
        "</", "p", ">",
    "</", "body", ">",
"</", "html", ">"
]</code></pre>
					<aside class="notes">
					</aside>
				</section>						

				<section>
					<h1>Lexer</h1>
					<ul>
						<li>Identifies the type of each token</li>
						<li>Outputs token stream for the parser</li>
					</ul>
					<aside class="notes">
						once input stream chopped into discrete tokens by tokenizer move to lexer
						<br>
						!!emitted tokens from tokenization are converted into "objects," which define have their own properties & rules!!
					</aside>
				</section>

				<section>
					<h1>Parser</h1>
					<ul>
						<li>Reads off lexer stream</li>
						<li>Compiler parses source code into a tree structure, and then translates that into machine code</li>
						<li>Responsible for analyzing the document structure according to the language syntax rules</li>
					</ul>
					<aside class="notes">
						alpha order: lex then parse
						<br>
						!!tree structure similiar to AST in JS!!
						<br>
						concerned with context in which token appears
						<br>
						cares about whether or not the sequence & combination of tokens detected fits expected grammar (the meanings of tokens, and if in acceptable order)
						<br>
						parser is part of compiler
					</aside>
				</section>

				<section>
					<h1>DOM</h1>
					<ul>
						<li>Source code &darr;</li>
						<li>Parsing &darr;</li>
						<li>Parse tree (think AST) &darr;</li>
						<li>Translation (compilation) &darr;</li>
						<li>Machine code</li>
					</ul>
					<aside class="notes">
						!!translation!!: turns AST into machine code
						<br>
						markup defines relation between tags (some tags contained within others)
						<br>
						created objs are linked in tree data structure that also captures parent-child relation from orig markup: HTML obj is parent of body obj, body parent of p obj, so on
					</aside>
				</section>

				<section>
					<h1>DOM</h1>
					<ul>
						<li>Not context free</li>
						<li>Never get a syntax error</li>
					</ul>
					<aside class="notes">
						when parsing, have to take into account surrounding chars
						<br>
						not defined - fudge factor
						<br>
						missing info, need more than the spec
						<br>
						edge cases
					</aside>
				</section>

				<section>
					<h1>Recap</h1>
					<ul>
						<li>Browser sends HTTP request for page</li>
						<li>Web server sends response</li>
						<li>Browser converts response data (bytes) into tokens, via tokenization</li>
						<li>Browser turns tokens into nodes</li>
						<li>Browser turns nodes into the DOM tree</li>
						<li>DOM tree construction finished</li>
						<li>Awaits CSSOM tree construction</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/confused.gif" >
					<aside class="notes">
						Now for CSS
						<br>
						DOM and CSSOM are independent data structures
						<br>
						As with HTML, need to convert received CSS rules into something browser can understand & work with. Hence, repeat HTML process, but for CSS instead
					</aside>
				</section>

				<section>
					<h1>CCSOM</h1>
					<ul>
						<li>By default CSS is treated as a render blocking resource</li>
						<li>Browser will hold rendering of any process until the CSSOM is constructed</li>
					</ul>
					<aside class="notes">
						While browser constructs DOM, encountered link tag in head referencing sheet. Anticipation = needs this for render, dispatches req || seems since sheets don't change DOM tree, no reason to stop parsing. Issue: scripts asking for style information during doc parsing. If style not loaded & parsed, script = wrong answers
					</aside>
				</section>

				<section>
					<h1>CCSOM</h1>
					<ul>
						<li>Not 1 to 1 with the DOM</li>
						<li>Display none, script tags, meta tags, head element, etc. are omitted since they're not reflected in the rendered output</li>
					</ul>
					<aside class="notes">
						DOM tree captures properties & relations of document markup, but doesn't tell how element will look when rendered. That’s responsibility of CSSOM
						<br>
						whereas elements with 'hidden' visibility will appear in the tree
					</aside>
				</section>

				<section>
					<h1>CCSOM</h1>
					<ul>
						<li>CSS files are parsed into stylesheet objects</li>
						<li>Each object contains a CSS rules object</li>
						<li>Each rules objects contains selector and declaration objects and other objects corresponding to CSS grammar</li>
					</ul>
					<aside class="notes">
						again, think AST/tree structure
						<br>
						Why tree structure? When computing final set of styles for any obj on pg, browser starts with most general rule applicable to a node (ex: if it's child of body element, then all body styles apply) then recursively refines the computed styles by applying more specific rules: rules cascade down
					</aside>
				</section>

				<section>
					<h1>Render Tree</h1>
					<h4>DOM + CCSOM</h4>
					<ul>
						<li>Visual representation of the document</li>
						<li>Enable painting the contents in their correct order</li>
						<li>CSSOM Can have drastic effects on the render tree but none on the DOM tree</li>
					</ul>
					<aside class="notes">
						tree is of visual elements in order in which displayed
					</aside>
				</section>

				<section>
					<h1>Purpose</h1>
					<ul>
						<li>Stores RenderObjects or "renderers" (AKA frames in Firefox)</li>
						<li>Knows how to lay out and paint itself and its children</li>
						<li>Includes geometric information like width, height and position</li>
						<li>Each node in the DOM tree that produces visual output has a corresponding RenderObject</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Construction</h1>
					<ul>
						<li>Starting at the root of the DOM tree, traverse each visible node</li>
						<li>Omit non visible nodes</li>
						<li>For each visible node find the appropriate matching CSSOM rules and apply them</li>
						<li>Emit visible nodes with content and their computed styles</li>
						<li>Final output is a render tree that contains both the content and style information of all visible content on the screen</li>
					</ul>
					<aside class="notes">
						to construct render tree, browser does following:
						<br>
						after render tree finally to layout stage
					</aside>
				</section>

				<section>
					<h1>Rendering Phases</h1>
					<ul>
						<li>Layout &darr;</li>
						<li>Paint &darr;</li>
						<li>Composite &darr;</li>						
					</ul>
					<aside class="notes">
						Chrome DevTools Timeline allows us to capture and inspect the construction and processing costs of DOM and CSSOM
						<br>
						open Chrome DevTools & record timeline while the page is loaded, can see actual time taken to perform steps
						<br>
						paint capture option, you can visualize composited layers at each frame of recording
					</aside>
				</section>

				<section>
					<h1>Layout</h1>
					<h4>(AKA Relow)</h4>
					<ul>
						<li>When the renderer is created and added to the tree, it does not have a position and size</li>
						<li>Calculating these values is called layout or reflow</li>
						<li>The output of the layout process is a box model that contains the position and size of every element within the viewport</li>
					</ul>
					<aside class="notes">
						up to this we’ve calculated which nodes should be visible and their computed styles
						<br>
						but haven't calculated their exact position & size within the viewport of the device
						<br>
						that’s the layout stage, also known as reflow
					</aside>
				</section>

				<section>
					<h1>Paint</h1>
					<h4>(AKA Rasterizing)</h4>
					<ul>
						<li>Once you have visible nodes (DOM), computed styles (CSSOM) and geometry (Layout), the information is passed to the second stage, painting</li>
						<li>Converts each node in the render tree to actual pixels on the screen</li>
					</ul>
					<aside class="notes">
						once render tree is constructed, browser can paint (draw) the render tree nodes on the screen
					</aside>
				</section>

				<section>
					<h1>Painting</h1>
					<ul>
						<li>Multiple rounds of painting can be caused by JS being loaded that changes the DOM</li>
						<li>Includes: text, colors, shadows, background images, etc.</li>
						<li>
							<a href="https://www.youtube.com/watch?v=ZTnIxIA5KGw">Gecko Reflow Visualization</a>
						</li>
					</ul>
					<aside class="notes">
						painting cont.
					</aside>
				</section>

				<section>
					<h1>Painting Time</h1>
					<ul>
						<li>Time varies based on render tree construction</li>
						<li>The bigger the width and height of the element, the longer the painting time</li>
						<li>Adding different effects also increases painting time</li>
					</ul>
					<aside class="notes">
						first thing to look for is the area of the element
					</aside>
				</section>
	
				<section>
					<h1>Painting Order</h1>
					<ul>
						<li>Follows order that elements are stacked in their stacking contexts</li>
						<li>Painted from back to front</li>
						<li>Example: background color &rarr; background image &rarr; border &rarr; children</li>
						<li>Can be global or incremental</li>
					</ul>
					<aside class="notes">
						order affects painting since stacks are painted back - front. Stacking order = 
						<br>
						like layout (entire tree painted or incremental - some renderers change in way that doesn't affect entire tree)
						changed renderer invalidates its rectangle on screen causing OS to see it as a 'dirty region' & generates a 'paint' event
					</aside>
				</section>
	
				<section>
					<h1>Composite</h1>
					<ul>
						<li>Render different elements of a web page in different layers (think photoshop layers)</li>
						<li>Action of flattening all layers into the final image that is visible on the screen</li>
					</ul>
					<aside class="notes">
						when pl speak of hardware acceleration in browsers, almost always refer to accelerated compositing
						<br>
						Using GPU to composite contents of a web page = speed up vs old CPU (CPU & GPU in parallel)
						<br>
						cache and group chunks of render tree
						<br>
						where painted parts put together
					</aside>
				</section>

				<section>
					<h1>Summary</h1>
					<ul>
						<li>Browsers try to do the minimal possible actions in response to a change</li>
						<li>Changes to an element's color will only repaint that element</li>
						<li>Changes to the element's' position will cause layout and repaint of that element, its children and possibly siblings</li>
						<li>Adding a DOM node will cause layout and repaint of the node</li>
						<li>Major changes, like increasing font size of the html element will cause invalidation of caches, relayout and repaint of the entire tree</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/delete.gif" >
					<aside class="notes">
						ever moved something around only to see another part of page break?
					</aside>
				</section>

				<section>
					<h1>Specificity</h1>
					<ul>
						<li>Applying rules in correct cascade order</li>
						<li>If multiple CSS selectors are targeting the same set of HTML elements, and if the CSS selectors are trying to assign the same property/properties to the HTML elements, the selector with the highest specificity value will win</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Specificity</h1>
					<ul>
						<li>Many ways to target a specific tag using CSS selectors</li>
						<li>Browser needs a way to negotiate which color it should give to a specific tag</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Specificity</h1>
					<ul>
						<li>Browser makes a decision by first calculating each selectors' specificity value</li>
						<li>Second, it checks which selector has the highest value to determine the winner</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Specificity</h1>
						<pre><code><div class="container">
 <div id="main">
  <p>
   <a href="#">Link</a>
  </p>
 </div>
</div></code></pre>
					<aside class="notes">
					</aside>
				</section>			

				<section>
					<h1>Specificity</h1>
						<pre><code>#main a {
  color: green;
}
p a {
  color: yellow;
}
.container #main a {
  color: pink;
}
div #main p a {
  color: orange;
}
a {
  color: red;
}</code></pre>
					<aside class="notes">
						a tag is pink!
					</aside>
				</section>		

				<section>
					<table>
					<tr>
						<th>Selector</th>
						<th>Specificity Value</th>
					</tr>
					<tr>
						<td>.container #main a</td>
						<td>111</td>
					</tr>
					<tr>
						<td>div #main p a</td>
						<td>103</td>
					</tr>	
					<tr>
						<td>#main a</td>
						<td>101</td>
					</tr>				
					<tr>
						<td>p a</td>
						<td>2</td>
					</tr>	
					<tr>
						<td>a</td>
						<td>1</td>
					</tr>							
					</table>
					<aside class="notes">
						a tag is pink!						
					</aside>
				</section>

				<section>
					<table>
					<tr>
						<th>Letter (ABC)</th>
						<th>Total number of...</th>
					</tr>
					<tr>
						<td>A</td>
						<td>
							<ul>
								<li>ID selectors</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>B</td>
						<td>
							<ul>
								<li>Class selectors</li>
								<li>Attribute selectors</li>
								<li>Pseudo-classes</li>
							</ul>
						</td>
					</tr>	
					<tr>
						<td>C</td>
						<td>
							<ul>
								<li>Type selectors</li>
								<li>Pseudo-elements</li>
							</ul>
						</td>
					</tr>								
					</table>
					<aside class="notes">
						had to write down my calculations on a piece of paper
					</aside>
				</section>

				<section>
					<table>
					<tr>
						<th>Type</th>
						<th>Examples</th>
					</tr>
					<tr>
						<td>Attribute selectors</td>
						<td>
							<ul>
								<li>[type="text"]</li>
								<li>[rel="nofollow"]</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>Pseudo-classes</td>
						<td>
							<ul>
								<li>:hover</li>
								<li>:visited</li>
							</ul>
						</td>
					</tr>	
					<tr>
						<td>Pseudo-elements</td>
						<td>
							<ul>
								<li>::before</li>
								<li>::after</li>
							</ul>
						</td>
					</tr>								
					</table>
					<aside class="notes">
						all know type (div) selectors, class and id...
					</aside>
				</section>

				<section>
					<h4>Specificity value: 122</h4>		
					<pre><code>#header .navbar li a:visited</code></pre>
					<table>
						<tr>
							<th>A</th>
							<th>B</th>
							<th>C</th>
						</tr>
						<tr>
							<td>1</td>
							<td>2</td>
							<td>2</td>
						</tr>
					</table>
					<aside class="notes">
						1 id, 1 class + 1 pseudo-class, 2 type selectors (li, a)
					</aside>
				</section>

				<section>
					<h1>Positioning</h1>
					<img src="img/css_is_awesome.jpg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Positioning</h1>
					<ul>
						<li>Before starting layout (positioning), a tree of render objects is created</li>
						<li>When renderers are first created and added to the tree, they have no position or size yet</li>
					</ul>
					<aside class="notes">
						process by which all boxes have their positions & sizes determined = going back to layout
						<br>
						can only happen once have the render tree						
						<br>
						all renderers have layout method
					</aside>
				</section>

				<section>
					<h1>Positioning</h1>
					<h4>Normal & Relative</h4>
					<ul>
						<li>Normal: The object is positioned according to its place in the document</li>
						<li>Relative: Positioned like usual and then moved by the required delta</li>
					</ul>
					<aside class="notes">
						norm: its place in render tree is like its place in DOM tree & is laid out according to its box type and dimensions
						<br>
						block box: have their own rectangle on the browser window
						<br>
						inline box: does not have its own block, is inside containing block
					</aside>
				</section>

				<section>
					<h1>Positioning</h1>
					<h4>Float</h4>
					<ul>
						<li>The object is first laid out like normal flow, then moved as far left or right as possible</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<h1>Positioning</h1>
					<h4>Absolute</h4>
					<ul>
						<li>The object is put in the render tree in a different place than in the DOM tree</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>		

				<section>
					<h1>Positioning Phases</h1>
					<ul>
						<li>Layout is a recursive process</li>
						<li>The current renderer computes its width</li>
						<li>For each child, the current renderer: determines the position of the child, asks the child to compute its dimensions, then the current renderer can compute its height</li>
					</ul>
					<aside class="notes">
						parent tells child to fit into it’s width
						<br>
						happens whenever position changes - repaint and then composite back together still needs to happen
					</aside>
				</section>

				<section>
					<h1>Global Layout</h1>
					<ul>
						<li>Layout can be triggered on the entire render tree as a result of a global style change that affects all renderers</li>
						<li>Global layout will usually be triggered synchronously</li>
						<li>Example: font size change, screen being resized</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Incremental layout</h1>
					<ul>
						<li>Layout can be incremental, where only the dirty renderers will be laid out</li>
						<li>Incremental layout is triggered asynchronously when renderers are dirty</li>
						<li>Example: new renderers are appended to the render tree after extra content came from the network and was added to the DOM tree</li>
					</ul>
					<aside class="notes">
						remember renderer object in render tree, knows how to layout & paint itself & children
					</aside>
				</section>

				<section>
					<h1>Z -Index</h1>
					<ul>
						<li>Every element in an HTML document can be either in front of or behind every other element in the document</li>
					</ul>
					<aside class="notes">
						so simple right?!
						<br>
						elements with higher z-index are stacked in front of elements with lower z-index
					</aside>
				</section>

				<section>
					<img src="img/so_hard.gif" >
					<aside class="notes">
					appears so simple, so most devs don’t take time to read rules
					</aside>
				</section>

				<section>
					<h1>AKA Stacking Order</h1>
					<ul>
						<li>Groups of elements with a common parent that move forward or backward together in the stacking order make up what is known as a stacking context</li>
						<li>Every stacking context has a single HTML element as its root element</li>
						<li>When z-index and position properties aren’t involved, the rules are simple: the stacking order is the same as the order of appearance in the HTML</li>
					</ul>
					<aside class="notes">
						layered representation
						<br>
						when you introduce position property, positioned elements (& children) are displayed in front of non-positioned elements
						<br>
						'positioned' means relative, absolute, etc. (value other than static)
					</aside>
				</section>

				<section>
					<h1>What is a stacking context?</h1>
					<ul>
						<li>A three-dimensional conceptualization of HTML elements along an imaginary z-axis relative to the user facing the viewport</li>
						<li>An element that contains a set of layers</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Stacking Context</h1>
					<h4>Types</h4>
					<ul>
						<li>Root Stacking Context: created by the html element</li>
						<li>Local Stacking Context: created by specific properties and values</li>
						<li>Within a local stacking context, the z-index values of children are relative to that element rather than to the document root</li>
						<li>Layers outside of that context (sibling elements of a local stacking context) can't sit between layers within it</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Stacking Context</h1>
					<h4>z-index</h4>
					<ul>
						<li>Can create new stacking contexts (this is where things get complicated)</li>
						<li>Only works on positioned elements (if you try to set a z-index on an element with no position specified, it won't do anything)</li>
					</ul>
					<aside class="notes">
						At first it’s natural to assume elements with higher z-index values are in front of elements with lower values
						<br>
						& any element with z-index is in front of any element without a z-index
						<br>
						but it’s not that simple
					</aside>
				</section>

				<section>
					<h1>Stacking Context</h1>
					<ul>
						<li>When a new stacking context is formed on an element, that stacking context confines all of its child elements to a particular place in the stacking order</li>
						<li>If an element is contained in a stacking context at the bottom of the stacking order, there is no way to get it to appear in front of another element in a different stacking context that is higher in the stacking order</li>
					</ul>
					<aside class="notes">
						full understanding of stacking contexts is key to grasping how z-index & stacking order work
						<br>
						diff contexts ? can't even change even with a z-index of billion!
					</aside>
				</section>

				<section>
					<h1>Stacking Context Rules</h1>
					<h4>Non-positioned elements</h4>
					<ul>
						<li>Check the stacking context’s root element</li>
						<li>Check order of appearance in the HTML</li>
					</ul>
					<aside class="notes">
						here are basic rules to determine stacking order w/in simple single stacking context (from back to front)
					</aside>
				</section>

				<section>
					<h1>Stacking Context Rules</h1>
					<h4>Positioned elements (and their children)</h4>
					<ul>
						<li>Negative z-index values: higher values are stacked in front of lower values and elements with the same value are stacked according to appearance in the HTML</li>
						<li>Negative z-indexes are ordered first within a stacking context, which means they appear behind all other elements</li>
					</ul>
					<aside class="notes">
						-1 higher than -5
						<br>
						(2)...because of this, possible for an element to appear behind own parent - normally not possible. Only works if element’s parent is in same stacking context & not root element of that context
					</aside>
				</section>

				<section>
					<h1>Stacking Context Rules</h1>
					<h4>Positioned elements (and their children)</h4>
					<ul>
						<li>Auto z-index values: ordered by appearance in the HTML</li>
						<li>Positive z-index values: higher values are stacked in front of lower values and elements with the same value are stacked according to appearance in the HTML</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>				

				<section>
					<h1>Painting order</h1>
					<ul>
						<li>Negative stack level, typically elements with z-index: -1</li>
						<li>Position value of static</li>
						<li>Stack level 0, typically positioned elements with a z-index value of auto</li>
						<li>Positive stack levels, e.g. a positioned element with a z-index value of 1 or higher</li>
						<li>Elements with the same stack level are layered based on their source order (successive elements stack on top of their predecessors)</li>
					</ul>
					<aside class="notes">
						children of a stacking context are painted from bottom to top in following order
					</aside>
				</section>

				<section>
					<h1>New Stacking Contexts</h1>
					<ul>
						<li>Opacity less than 1, filter when its value is something other than none, and mix-blend-mode when its value is something other than normal</li>
						<li>Transform property also triggers a stacking context when its value isn't none. Examples: scale(1), translate3d(0,0,0)</li>
					</ul>
					<aside class="notes">
						blend mode determines how the pixels on that layer interact with the visible pixels on the layers below it
						<br>
						scale: size, translate3d: GPU into action for CSS transitions, making them smoother
					</aside>
				</section>

				<section>
					<h1>Debugging z-index</h1>
					<ul>
						<li>Be able to spot when new stacking contexts are formed</li>
						<li>Look up the ancestor tree and see if any parents form stacking contexts</li>
					</ul>
					<aside class="notes">
						<br>
						(2) if setting z-index of billion on element & not moving forward in stacking order...
						<br>
						if new stack context, z-index of billion isn’t doing any good
					</aside>
				</section>

				<section>
					<h1>Conclusion</h1>
					<ul>
						<li>Construct the DOM by parsing the HTML</li>
						<li>May be incremental and a response may not arrive all at once, so may not finish construction all at once</li>
						<li>Request CSS and JavaScript resources</li>
						<li>If scripts are synchronous it will not be executed until the CSS is received (CSS is render-blocking)</li>
					</ul>
					<aside class="notes">
						here are steps the browser goes through when loading a page
					</aside>
				</section>

				<section>
					<h1>Conclusion</h1>
					<ul>
						<li>Complete CSSOM construction to un-block the JavaScript engine</li>
						<li>Execute JavaScript</li>
						<li>Merge the DOM and CSSOM into the Render Tree</li>
						<li>Run layout, paint, and composite</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/angry.gif" >
					<aside class="notes">
					</aside>
				</section>

				<section>
					<img src="img/happy.gif" >
					<aside class="notes">
					</aside>
				</section>

				<section style="text-align: left;">
					<h1>Thank you!</h1>
					<ul>
						<li><a href="https://twitter.com/Aimee_Knight">@Aimee_Knight</a></li>
						<li><a href="https://github.com/AimeeKnight">GitHub: AimeeKnight</a></li>
					</ul>
				</section>

				<section>
					<ul>
						<li>
							<a href="https://gist.github.com/AimeeKnight/77b36738ec876965c6db5c6d39f4ef4f">References</a>
						</li>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
